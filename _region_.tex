\message{ !name(main.tex)}\documentclass[acmsmall, nonacm, review]{acmart}

% supress font size warnings
\usepackage{anyfontsize}
\usepackage{fix-cm}

\let\Bbbk\relax % avoid clash

\usepackage{amsmath,amssymb,bm,amsfonts,amsthm,mathtools}
\usepackage[only,llbracket,rrbracket,llparenthesis,rrparenthesis]{stmaryrd}
\usepackage{physics}
\usepackage{mathpartir}
\usepackage{tikz-cd}
\usepackage{qcircuit}
\usepackage{thm-restate}

\usetikzlibrary{positioning, arrows.meta, shapes.multipart, shadows, shapes.geometric, math}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{dfn}[thm]{Definition}
\newtheorem{ex}[thm]{Example}
\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}

\tikzset{
  node distance=1cm and 1.5cm,
  title/.style={
      font=\bfseries\small
    },
  mem/.style={
      rectangle,
      draw,
      thick,
      fill=blue!10,
      minimum height=1cm,
      minimum width=1cm,
      drop shadow
    },
  op/.style={
      ellipse,
      draw,
      thick,
      fill=green!10,
      minimum height=0.6cm,
      minimum width=0.9cm
    },
  arr/.style={
      -Stealth,
      thick
    }
}

\title{A Non-linear Quantum Lambda Calculus}
\author{Rikiya Kashiwagi}
\author{Atsushi Igarashi}
\affiliation{%
  \institution{Kyoto University}
  \department{Graduate School of Informatics}
  \city{Kyoto}
  \country{Japan}
}
\email{{kashiwagi,igarashi}@fos.kuis.kyoto-u.ac.jp}

\begin{abstract}
  This paper presents a quantum extension of lambda calculus without linearity, reinterpreting contraction and weakening as logical operations on references to quantum states, rather than on the states themselves.
  The proposed calculus is a conservative extension of the normal lambda calculus, preserving its operational equivalence.
  This provides a familiar yet powerful framework for hybrid quantum-classical programming.
\end{abstract}

%\keywords{quantum programming language, lambda calculus}

\begin{document}

\message{ !name(appendixC.tex) !offset(-79) }
\section{Type system} \label{sec:type-system}
We present the simple type system of $\Lambda(\mathcal{U})$ calculus.
Syntax of types and typing context is given as follows.
\begin{equation*}
  \begin{array}{lrl}
    \text{Types}          & A, B, C \Coloneqq          & \top\mid A\otimes B\mid A\oplus B\mid A\rightarrow B    \\
    \text{Basis types}    & \hat{A}, \hat{B} \Coloneqq & \top\mid\hat{A}\otimes \hat{B}\mid\hat{A}\oplus \hat{B} \\
    \text{Typing context} & \Gamma \Coloneqq           & \epsilon \mid \Gamma,x:A                                \\
  \end{array}
\end{equation*}
The types include the unit type $\top$, product types $A \otimes B$, sum types $A \oplus B$, and function types $A \rightarrow B$.
$\otimes$ and $\oplus$ indicate that they are tensor product and direct sum of Hilbert spaces when interpreted as superpositions.
Crucially, there is no distinction between classical and quantum types in this system.
For instance, the type of both classical bit and qubit are represented as the same $\top \oplus \top$.

Typing judgements are defined on the runtime terms, which means they include typing rules for store locations.
In order to map locations to their types, we introduce the notion of store typing.
\begin{dfn}[Store typing]
  A store typing $\Sigma$ is a finite mapping from locations to basis types.
  A store $\sigma$ is well-typed under $\Sigma$, denoted $\vdash \sigma : \Sigma$, if for every $l\in\text{dom}(\Sigma)$, $\vdash \sigma(l) : \Sigma(l)$ holds.
\end{dfn}

Similar to the definition of the reduction relation, we assume a typing judgement for $\hat{U}\in\mathcal{U}$ in the form of $\vdash_\mathcal{U} \hat{U} : \hat{A} \rightarrow \hat{B}$.
\begin{dfn}[Typing judgments]
  Given a set of external typing judgements $\vdash_\mathcal{U} \hat{U} : \hat{A} \rightarrow \hat{B}$ for $\hat{U}\in\mathcal{U}$,
  A typing judgment is of the form $\Sigma \mid \Gamma \vdash M : A$.
  The typing rules are given in Fig.~\ref{fig:typing}.
\end{dfn}

\begin{figure}[t]
  \begin{mathpar}
    \inferrule*[right=Loc]
    { l\in\text{dom}(\Sigma) }
    { \Sigma\mid\Gamma \vdash l : \Sigma(l) }
    \and
    \inferrule*[right=$\top$-I]
    {  }
    { \Sigma\mid\Gamma \vdash * : \top }
    \and
    \inferrule*[right=$\pi_1$]
    { }
    { \Sigma\mid\Gamma,x : A \vdash x : A }
    \and
    \inferrule*[right=$\pi_2$]
    { \Sigma\mid\Gamma \vdash x : A }
    { \Sigma\mid\Gamma,y : B \vdash x : A }
    \and
    \inferrule*[right=$\rightarrow$-I]
    { \Sigma\mid\Gamma, x : A \vdash M : B }
    { \Sigma\mid\Gamma \vdash \lambda x.M : A\rightarrow B }
    \and
    \inferrule*[right=$\rightarrow$-E]
    { \Sigma\mid\Gamma \vdash M : A \rightarrow B \\
      \Sigma\mid\Gamma \vdash N : A }
    { \Sigma\mid\Gamma \vdash M\ N : B }
    \and
    \inferrule*[right=$\otimes$-I]
    { \Sigma\mid\Gamma \vdash M : A \\
      \Sigma\mid\Gamma \vdash N : B }
    { \Sigma\mid\Gamma \vdash \langle M,N\rangle : A\otimes B }
    \and
    \inferrule*[right=$\oplus_0$-I]
    { \Sigma\mid\Gamma \vdash M : A }
    { \Sigma\mid\Gamma \vdash \texttt{inj}_0\ M : A\oplus B }
    \and
    \inferrule*[right=$\oplus_1$-I]
    { \Sigma\mid\Gamma \vdash M : B }
    { \Sigma\mid\Gamma \vdash \texttt{inj}_1\ M : A\oplus B }
    \and
    \inferrule*[right=Op]
    { \vdash_\mathcal{U} \hat{U} : \hat{A} \rightarrow \hat{B} }
    { \Sigma\mid\Gamma \vdash \hat{U} : \hat{A} \rightarrow \hat{B} }
    \and
    \inferrule*[right=$\otimes$-E]
    { \Sigma\mid\Gamma \vdash M : A\otimes B \\
      \Sigma\mid\Gamma,x:A,y:B \vdash N : C }
    { \Sigma\mid\Gamma \vdash \texttt{let}\ \langle x,y\rangle=M\ \texttt{in}\ N : C }
    \and
    \inferrule*[right=$\oplus$-E]
    { \Sigma\mid\Gamma \vdash M : A \oplus B \\
    \Sigma\mid\Gamma, x : A \vdash N : C \\
    \Sigma\mid\Gamma, y : B \vdash P : C }
    { \Sigma\mid\Gamma \vdash \texttt{match}\ M\ [x\Rightarrow N\mid y\Rightarrow P] : C }
  \end{mathpar}
  \caption{Typing rules}
  \label{fig:typing}
  \Description{A set of inference rules defining the typing rules for the Lambda(U) calculus. The rules cover typing for locations, unit type, variable projection, lambda abstraction and application, tensor product introduction and elimination, sum type introduction and elimination, and operations from the set of unitaries. Each rule specifies how a term can be assigned a type based on its structure and the types of its components.}
\end{figure}

% safety properties
We can show the standard type safety properties, i.e., subject reduction and progress.
\begin{thm}[Subject reduction]
  If $\Sigma\mid\Gamma \vdash M : A$, $[\sigma,M] \to [\sigma',M']$ and $\vdash \sigma : \Sigma$,
  then there exists $\Sigma'$ such that $\Sigma' \mid \Gamma \vdash M^{*'} : A$ and $\vdash \sigma' : \Sigma'$.
\end{thm}

\begin{thm}[Progress]
  If $\Sigma \mid \Gamma \vdash M : A$,
  then either $M$ is a value or there exists $\mu$ such that $[\sigma,M] \to \mu$.

\end{thm}

\subsection{Contetual equivalence}

\begin{equation}
  \Gamma \vdash M \approx N : A = \forall C[\cdot] \in \Lambda(\mathcal{U}).\ \vdash C : (\emptyset\mid\Gamma \vdash A)\doublerightarrow (\emptyset\mid\epsilon\vdash B) \Rightarrow (C[M]\Downarrow \Leftrightarrow C[N])
\end{equation}

\message{ !name(main.tex) !offset(-94) }

\end{document}
