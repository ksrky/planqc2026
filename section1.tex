\section{Introduction} \label{sec:intro}
The theoretical foundations of quantum programming languages have largely been built upon linear logic and its variants\cite{VANTONDER2004_LambdaCalculusQuantum,SELINGER2009_QuantumLambdaCalculus,ALTENKIRCH2005_FunctionalQuantumProgramming,SABRY2018_SymmetricPatternMatchingQuantum,ROSS2017_AlgebraicLogicalMethods}, reflecting the \textit{No-Cloning} Theorem\cite{WOOTTERS1982_SingleQuantumCannota} and the \textit{No-Deleting} Theorem\cite{KUMARPATI2000_ImpossibilityDeletingUnknowna} of quantum mechanics.
Within this paradigm, variables representing quantum states are treated as linear resources that can be neither duplicated (contracted) nor discarded (weakened).
While this linearity ensures the physical correctness, it creates a significant gap with the intutions of classical, non-linear programming.

This paper proposes a quantum language designed as a direct extension of the normal (non-linear) lambda calculus.
Our central design principle is to ensure that this extension behaves conservatively with respect to the original lambda calculus; specifically, $\beta$-equivalent terms remain operationally indistinguishable in the quantum extension.
This approach ensures any embedded classical program executes with its standard semantics, enabling seamless integration of classical and quantum programs.

A key consequence of enforcing this principle is that the quantum features of the language are cleanly isolated from the classical host.
This quantum-native fragment, consisting of encapsulated unitary operations, forms a distinct module for expressing quantum control.
This separation provides a natural framework that enables coexistence of the historically separate paradigms of `\textit{Quantum Data, Classical Control}'\cite{SELINGER2004_QuantumProgrammingLanguage} and `\textit{Quantum Data, Quantum Control}'\cite{D√çAZ-CARO2022_QuickOverviewQuantum}.
That means a programmer can compose the main logic in a higher-order classical style, while delegating complex quantum subroutines to specialized, domain-specific modules.
The resulting language provides a familiar framework for classical programmers and, at the same time, introduces a structured and powerful abstraction for high-level quantum-classical programming.
